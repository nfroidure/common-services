[//]: # ( )
[//]: # (This file is automatically generated by the `jsarch`)
[//]: # (module. Do not change it elsewhere, changes would)
[//]: # (be overriden.)
[//]: # ( )
# Architecture Notes

## Summary

1. [Services](#1-services)
   1. [Logging](#11-logging)
      1. [Mocking logs](#11.1-mocking-logs)
   2. [Time](#12-time)
      1. [Mocking time](#12.1-mocking-time)
   3. [Randomness](#13-randomness)
      1. [Mocking randomness](#13.1-mocking-randomness)
   4. [Delaying](#14-delaying)
      1. [Mocking delays](#14.1-mocking-delays)
   5. [Process](#15-process)
      1. [Node environment filtering](#15.1-node-environment-filtering)
      2. [Signals handling](#15.2-signals-handling)
      3. [Handling services fatal errors](#15.3-handling-services-fatal-errors)
      4. [Uncaught exceptions](#15.4-uncaught-exceptions)
   6. [Counter](#16-counter)
   7. [Code generator](#17-code-generator)
   8. [Lock](#18-lock)


## 1. Services

Since the services in this module are very common, we
 provide a helper to require them all with a single
 line of code.

Their goal is to encapsulate unpredictible states and
 inputs/outputs of the software they are part of. They
 are primarily meant to be used with
 [`knifecycle`](https://github.com/nfroidure/knifecycle)
 but should be usable with any DI system or even rawly.

[See in context](./src/index.ts#L1-L12)



### 1.1. Logging

I prefer using a unique function with the log type
 in parameter instead of several methods for each
 log types. It is far easyer to mock and to assert
 on logs in my tests.

If provided, I route debug messages to the `debug`
 node module.

[See in context](./src/log.ts#L53-L63)



#### 1.1.1. Mocking logs

The log mock uses the
 [`sinon`](https://github.com/sinonjs/sinon/)
 module under the hood. I inject it in my tests
 and make assertions on its given args.

For example:
```js1
import initLogMock from 'common-services/dist/log.mock';
import myTestedFunction from 'mylib';

describe('my test', () => {
  let log;

  beforeAll((done) => {
    initLogMock()
    .then((_log_) => {
      log = _log_;
    })
    .then(done)
    .catch(done);
  });

  beforeEach(() => {
    log.reset();
  });

  test('should not log when no arg', () => {
    myTestedFunction();

    // Here I could use `callCount` or other `sinon`
    // helpers but the fact to always use
    // `assert.deepEqual` and the `sinon` args property
    // give immediate input on what was wrong:
    // if it had been called, we would see how many
    // times and with which args in the tests output.
    assert.deepEqual(logs.args, [], 'No log');
  });

  test('should log its args', () => {
    myTestedFunction('wadup', 'kikoo', 'lol');

    assert.deepEqual(logs.args, [[
      'info', 'wadup', 'kikoo', 'lol',
    ]], 'Logger output args');
  });

});
```

[See in context](./src/log.mock.ts#L5-L55)



### 1.2. Time

The time service is just proxying [`Date.now`
](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Date/now)
 in a stubbable manner.

[See in context](./src/time.ts#L12-L17)



#### 1.2.1. Mocking time

The time mock uses the [`sinon`](https://github.com/sinonjs/sinon/)
 module under the hood like for the logging mock.

[See in context](./src/time.mock.ts#L6-L10)



### 1.3. Randomness

The random service is just proxying [`Math.random`
](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
 in a stubbable manner.

[See in context](./src/random.ts#L12-L17)



#### 1.3.1. Mocking randomness

The random mock uses the [`sinon`](https://github.com/sinonjs/sinon/)
 module under the hood like for the logging mock.

[See in context](./src/random.mock.ts#L5-L9)



### 1.4. Delaying

The delay service is `setTimeout` like I would like it
 to be.

[See in context](./src/delay.ts#L18-L22)



#### 1.4.1. Mocking delays

This mock is largely inspired by the `$timeout` one of
 AngularJS. It allows to resolve/reject pending delays
 for testing. That said, it does it asynchronously
 where the former one was synchronous. This is not a
 bug but a design choice to keep the closest possible
 to what would happen in actual code.

[See in context](./src/delay.mock.ts#L5-L13)



### 1.5. Process

The `process` service takes care of the process status.

It returns nothing and should be injected only for its
 side effects.

[See in context](./src/process.ts#L27-L32)



#### 1.5.1. Node environment filtering

It also forces NODE_ENV to be set to avoid unintentionnal
 development version shipping to production. You can specify
 your own list of valid environments by injecting the
 `SIGNALS` optional dependency.

[See in context](./src/process.ts#L63-L69)



#### 1.5.2. Signals handling

It also handle SIGINT and SIGTERM signals to allow to
 gracefully shutdown the running process. The signals
 to handle can be customized by injecting the `SIGNALS`
 optional dependencies.

[See in context](./src/process.ts#L79-L85)



#### 1.5.3. Handling services fatal errors

If an error occurs it attempts to gracefully exit
to give it a chance to finish properly.

[See in context](./src/process.ts#L90-L94)



#### 1.5.4. Uncaught exceptions

If an uncaught exeption occurs it also attempts to
 gracefully exit since a process should never be kept
 alive when an uncaught exception is raised.

[See in context](./src/process.ts#L101-L106)



### 1.6. Counter

The `counter` service provide a simple, local and
 stubbable counter.

The count are returned asynchronously in order
 to be easily maintained across several instances
 if needed later via another service with the same
 surface API.

[See in context](./src/counter.ts#L23-L32)



### 1.7. Code generator

The `codeGenerator` service provide a service
 that generate random strings composed of
 a character set that avoid recognition
 mistake by humans.

[See in context](./src/codeGenerator.ts#L20-L26)



### 1.8. Lock

This service allows to maintain a lock on a given resource in order
 to ensure a sequential access to it in asynchronous code.

The release is done by its key and the current lock is removed. There
 is no check on the fact the lock is well released. By design, it is
 your responsibility to ensure you release the locks properly. That
 said, it should not be hard to handle since the actual behavior of
 the library makes your code run sequentially.

[See in context](./src/lock.ts#L28-L38)

